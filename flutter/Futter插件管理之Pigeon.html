<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>林小辉的blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Just recrod something">
    
    <link rel="preload" href="/assets/css/0.styles.35bcedcf.css" as="style"><link rel="preload" href="/assets/js/app.5d71a1c6.js" as="script"><link rel="preload" href="/assets/js/2.c183a324.js" as="script"><link rel="preload" href="/assets/js/4.24aaf822.js" as="script"><link rel="prefetch" href="/assets/js/10.dcea7a3e.js"><link rel="prefetch" href="/assets/js/11.c7f66434.js"><link rel="prefetch" href="/assets/js/12.de03b6e0.js"><link rel="prefetch" href="/assets/js/13.d9910249.js"><link rel="prefetch" href="/assets/js/14.fafe36af.js"><link rel="prefetch" href="/assets/js/15.03949b40.js"><link rel="prefetch" href="/assets/js/16.05df2604.js"><link rel="prefetch" href="/assets/js/17.fa250f32.js"><link rel="prefetch" href="/assets/js/18.a5e0229d.js"><link rel="prefetch" href="/assets/js/19.4183787b.js"><link rel="prefetch" href="/assets/js/20.90ed0136.js"><link rel="prefetch" href="/assets/js/21.cd3b3939.js"><link rel="prefetch" href="/assets/js/22.3050d27e.js"><link rel="prefetch" href="/assets/js/23.d2874efe.js"><link rel="prefetch" href="/assets/js/24.79cca016.js"><link rel="prefetch" href="/assets/js/25.9c5b0a09.js"><link rel="prefetch" href="/assets/js/26.69d37c61.js"><link rel="prefetch" href="/assets/js/27.c6142c6d.js"><link rel="prefetch" href="/assets/js/3.e88f59e6.js"><link rel="prefetch" href="/assets/js/5.0f611b7f.js"><link rel="prefetch" href="/assets/js/6.148a2419.js"><link rel="prefetch" href="/assets/js/7.1ab69c09.js"><link rel="prefetch" href="/assets/js/8.c66ae691.js"><link rel="prefetch" href="/assets/js/9.4438a384.js">
    <link rel="stylesheet" href="/assets/css/0.styles.35bcedcf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">林小辉的blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://www.zhihu.com/column/linxiaohui" target="_blank" rel="noopener noreferrer" class="nav-link external">
  知乎
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="https://github.com/linpenghui958" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://www.zhihu.com/column/linxiaohui" target="_blank" rel="noopener noreferrer" class="nav-link external">
  知乎
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="https://github.com/linpenghui958" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Flutter相关</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/flutter/Flutter零基础介绍.html" class="sidebar-link">Flutter介绍</a></li><li><a href="/flutter/Futter插件管理之Pigeon.html" class="active sidebar-link">/flutter/Futter插件管理之Pigeon.html</a></li><li><a href="/flutter/Flutter FPS 监控.html" class="sidebar-link">如何获取Flutter APP的FPS</a></li><li><a href="/flutter/本地编译FlutterEngine.html" class="sidebar-link">本地编译FlutterEngine</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue2.0</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>面试</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其他</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p><img src="/assets/img/pigeon.db8e754a.jpg" alt="enter image description here"></p> <h3 id="flutter插件开发之pigeon"><a href="#flutter插件开发之pigeon" class="header-anchor">#</a> Flutter插件开发之Pigeon</h3> <blockquote><p>导语：跨端开发中，经常会遇到插件，接口管理上的问题。了解完本文，你将会Flutter是如何通过Pigeon去解决plugin中多端开发难以管理的问题。</p></blockquote> <p><a href="https://github.com/linpenghui958/flutterPigeonDemo" target="_blank" rel="noopener noreferrer">demo源码地址<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>warning：目前Pigeon还是prerelease版本，所以可能会有breaking change。下文以0.1.7版本为例。</p> <p>[toc]</p> <h4 id="为何需要pigeon"><a href="#为何需要pigeon" class="header-anchor">#</a> 为何需要Pigeon</h4> <p>在hybird开发中，前端需要native能力，需要native双端开发提供接口。这种情况下就如何规范命名，参数等就成了一个问题，如果单独维护一份协议文件，三端依照协议文件进行开发，很容易出现协议更改后，没有及时同步，又或者在实际开发过程没有按照规范，可能导致各种意外情况。
在Flutter插件包的开发中，因为涉及到native双端代码实现能力，dart侧暴露统一的接口给使用者，也会出现同样的问题，这里Flutter官方推荐使用Pigeon进行插件管理。</p> <h4 id="pigeon的作用"><a href="#pigeon的作用" class="header-anchor">#</a> Pigeon的作用</h4> <p>Flutter官方提供的Pigeon插件，通过dart入口，生成双端通用的模板代码，Native部分只需通过重写模板内的接口，无需关心methodChannel部分的具体实现，入参，出参也均通过生成的模板代码进行约束。
假设接口新增，或者参数修改，只需要在dart侧更新协议文件，生成双端模板，即可达到同步更新。</p> <p>以Flutter官方plugin中的video_player为例，接入pigeon后最终效果如下</p> <p><img src="/assets/img/pigeon1.63f57823.png" alt="demo"></p> <p>可以看到接入pigeon后整体代码简洁了不少，而且规范了类型定义。接下来我们看一下如何从零接入Pigeon。</p> <h4 id="接入pigeon"><a href="#接入pigeon" class="header-anchor">#</a> 接入Pigeon</h4> <p>先看一下pub.dev上Pigeon的<a href="https://pub.dev/packages/pigeon" target="_blank" rel="noopener noreferrer">介绍<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，Pigeon只会生成Flutter与native平台通信所需的模板代码，没有其他运行时的要求，所以也不用担心Pigeon版本不同而导致的冲突。（这里的确不同版本使用起来差异较大，笔者这里接入的时候0.1.7与0.1.10，pigeon默认导出和使用都不相同）</p> <h5 id="创建package"><a href="#创建package" class="header-anchor">#</a> 创建package</h5> <p>ps：如果接入已有plugin库，可以跳过此部分，直接看接入部分。</p> <p>执行生成插件包命令：</p> <div class="language- extra-class"><pre class="language-text"><code>flutter create --org com.exmple --template plugin flutterPigeonDemo
</code></pre></div><p>要创建插件包，使用<code>--template=plugin</code>参数执行<code>flutter create</code></p> <ul><li><code>lib/flutter_pigeon_demo.dart</code> <ul><li>插件包的dart api</li></ul></li> <li><code>android/src/main/kotlin/com/example/flutter_pigeon_demo/FlutterPigeonPlugin.kt</code> <ul><li>插件包Android部分的实现</li></ul></li> <li><code>ios/Classes/FlutterPigeonDemoPlugin.m</code> <ul><li>插件包ios部分的实现。</li></ul></li> <li><code>example/</code> <ul><li>使用该插件的flutterdemo。</li></ul></li></ul> <p>这里常规通过methodChannel实现plugin的部分省略，主要讲解一下如何接入pigeon插件。</p> <h5 id="添加依赖"><a href="#添加依赖" class="header-anchor">#</a> 添加依赖</h5> <p>首先在<code>pubspec.yaml</code>中添加依赖</p> <div class="language- extra-class"><pre class="language-text"><code>dev_dependencies:
  flutter_test:
    sdk: flutter
  pigeon:
    version: 0.1.7
</code></pre></div><p>然后按照官方的要求添加一个pigeons目录，这里我们放dart侧的入口文件，内容为接口、参数、返回值的定义，后面通过pigeon的命令，生产native端代码。</p> <p>这里以<code>pigeons/pigeonDemoMessage.dart</code>为例</p> <div class="language- extra-class"><pre class="language-text"><code>import 'package:pigeon/pigeon.dart';

class DemoReply {
  String result;
}

class DemoRequest {
  String methodName;
}

// 需要实现的api
@HostApi()
abstract class PigeonDemoApi {
  DemoReply getMessage(DemoRequest params);
}

// 输出配置
void configurePigeon(PigeonOptions opts) {
  opts.dartOut = './lib/PigeonDemoMessage.dart';
  opts.objcHeaderOut = 'ios/Classes/PigeonDemoMessage.h';
  opts.objcSourceOut = 'ios/Classes/PigeonDemoMessage.m';
  opts.objcOptions.prefix = 'FLT';
  opts.javaOut =
  'android/src/main/kotlin/com/example/flutter_pigeon_demo/PigeonDemoMessage.java';
  opts.javaOptions.package = 'package com.example.flutter_pigeon_demo';
}
</code></pre></div><p><code>pigeonDemoMessage.dart</code>文件中定义了请求参数类型、返回值类型、通信的接口以及pigeon输出的配置。</p> <p>这里<code>@HostApi()</code>标注了通信对象和接口的定义，后续需要在native侧注册该对象，在Dart侧通过该对象的实例来调用接口。</p> <p><code>configurePigeon</code>为执行pigeon生产双端模板代码的输出配置。</p> <ul><li><code>dartOut</code>为dart侧输出位置</li> <li><code>objcHeaderOut、objcSourceOut</code>为iOS侧输出位置</li> <li><code>prefix</code>为插件默认的前缀</li> <li><code>javaOut、javaOptions.package</code>为Android侧输出位置和包名</li></ul> <p>之后我们只需要执行如下命令，就可以生成对应的代码到指定目录中。</p> <div class="language- extra-class"><pre class="language-text"><code>flutter pub run pigeon --input pigeons/pigeonDemoMessage.dart
</code></pre></div><ul><li><code>--input</code>为我们的输入文件</li></ul> <p>生成模板代码后的项目目录如下</p> <p><img src="/assets/img/pigeon2.55eb2e55.png" alt="catalogue"></p> <p>我们在Plugin库中只需要管理标红的dart文件，其余标绿的则为通过Pigeon自动生成的模板代码。</p> <p>我们接下来看一下双端如何使用Pigeon生成的模板文件。</p> <h5 id="android端接入"><a href="#android端接入" class="header-anchor">#</a> Android端接入</h5> <p>这里Pigeon生产的<code>PigeonDemoMessage.java</code>文件中，可以看到入参和出参的定义<code>DemoRequest、DemoReply</code>，而<code>PigeonDemoApi</code>接口，后面需要在plugin中继承PigeonDemoApi并实现对应的方法，其中setup函数用来注册对应方法所需的methodChannel。</p> <blockquote><p>ps: 这里生成的PigeonDemoApi部分，setup使用了接口中静态方法的默认实现，这里需要api level 24才能支持，这里需要注意一下。</p> <p>考虑到兼容性问题，可以将setup的定义转移到plugin中。</p></blockquote> <p>首先需要在plugin文件中引入生成的PigeonDemoMessage中的接口和类。
FlutterPigeonDemoPlugin先要继承PigeonDemoApi。
然后在onAttachedToEngine中进行PigeonDemoApi的setup注册。并在plugin中重写PigeonDemoApi中定义的getMessage方法</p> <p>伪代码部分</p> <div class="language- extra-class"><pre class="language-text"><code>// ... 省略其他引入
import com.example.flutter_pigeon_demo.PigeonDemoMessage.*

// 继承PigeonDemoApi
public class FlutterPigeonDemoPlugin: FlutterPlugin, MethodCallHandler, PigeonDemoApi {

	//...
	override fun onAttachedToEngine(@NonNull flutterPluginBinding: FlutterPlugin.FlutterPluginBinding) {
    	channel = MethodChannel(flutterPluginBinding.getFlutterEngine().getDartExecutor(), &quot;flutter_pigeon_demo&quot;)
    	channel.setMethodCallHandler(this);
    	// pigeon生成的api进行初始化
    	PigeonDemoApi.setup(flutterPluginBinding.binaryMessenger, this);
  	}
  	
  	// 重写PigeonDemoApi中的getMessage方法
	  override fun getMessage(arg: DemoRequest): DemoReply {
	    	var reply = DemoReply();
	    	reply.result = &quot;pigeon demo result&quot;;
	    	return reply;
	}
}

</code></pre></div><h5 id="ios接入"><a href="#ios接入" class="header-anchor">#</a> iOS接入</h5> <p>ios相关目录下的<code>PigeonDemoMessage.m</code>也有<code>FLTDemoReply、FLTDemoRequest、FLTPigeonDemoApiSetup</code>的实现。
首先需要在plugin中引入头文件<code>PigeonDemoMessage.h</code>，需要在registerWithRegistrar中注册setup函数，并实现getMessage方法。</p> <div class="language- extra-class"><pre class="language-text"><code>#import &quot;FlutterPigeonDemoPlugin.h&quot;
#import &quot;PigeonDemoMessage.h&quot;

@implementation FlutterPigeonDemoPlugin
+ (void)registerWithRegistrar:(NSObject&lt;FlutterPluginRegistrar&gt;*)registrar {
    FlutterPigeonDemoPlugin* instance = [[FlutterPigeonDemoPlugin alloc] init];
    // 注册api
    FLTPigeonDemoApiSetup(registrar.messenger, instance);
}

// 重写getMessage方法
- (FLTDemoReply*)getMessage:(FLTDemoRequest*)input error:(FlutterError**)error {
    FLTDemoReply* reply = [[FLTDemoReply alloc] init];
    reply.result = @&quot;pigeon demo result&quot;;
    return reply;
}

@end

</code></pre></div><h5 id="dart侧使用"><a href="#dart侧使用" class="header-anchor">#</a> Dart侧使用</h5> <p>最终在dart侧如何调用呢
首先看一下lib下Pigeon生成的dart文件<code>PigeonDemoMessage.dart</code> <code>DemoReply、DemoRequest</code>用来实例化入参和出参
然后通过<code>PigeonDemoApi</code>的实例去调用方法。</p> <div class="language- extra-class"><pre class="language-text"><code>import 'dart:async';

import 'package:flutter/services.dart';
import 'PigeonDemoMessage.dart';

class FlutterPigeonDemo {
  static const MethodChannel _channel =
      const MethodChannel('flutter_pigeon_demo');

  static Future&lt;String&gt; get platformVersion async {
    final String version = await _channel.invokeMethod('getPlatformVersion');
    return version;
  }

  static Future&lt;DemoReply&gt; testPigeon() async {
    // 初始化请求参数
    DemoRequest requestParams = DemoRequest()..methodName = 'requestMessage';
    // 通过PigeonDemoApi实例去调用方法
    PigeonDemoApi api = PigeonDemoApi();
    DemoReply reply = await api.getMessage(requestParams);
    return reply;
  }

}

</code></pre></div><p>至此，Pigeon的接入就已经完成了。</p> <h4 id="接入pigeon后的效果"><a href="#接入pigeon后的效果" class="header-anchor">#</a> 接入Pigeon后的效果</h4> <p>本文demo代码较为简单，接入Pigeon前后的差异并不明显，我们可以看下一Flutter官方plugin中的video_player接入前后的对比。</p> <p>左侧为接入Pigeon前，处理逻辑都在onMethodCall中，不同的方法通过传入的call.method来区分，代码复杂后很容易变成面条式代码，而且返回的参数也没有约定，有较多不确定因素。</p> <p>右侧接入Pigeon后，只需要重写对应的方法，逻辑分离，直接通过函数名区分，只需要关心具体的业务逻辑即可。</p> <p><img src="/assets/img/pigeon4.8e769819.png" alt=""></p> <p>而在dart的调用侧，接入前都是通过invokeMethod调用，传入的参数map内也是dynamic类型的值。接入后直接调用api的实例对象上的方法，并且通过Pigeon生成的模板代码，直接实例化参数对象。</p> <p><img src="/assets/img/pigeon3.5374d478.png" alt="pigeon3"></p> <p>总结：通过Pigeon来管理Flutter的plugin库，只需要在dart侧维护一份协议即可，即使在多端协同开发的情况下，也能达到约束和规范的作用。</p> <p>在实现原生插件时我们可以省去很多重复代码，并且不需要关心具体methodchannel的name，也避免了常规情况下，可能出现的面条式代码，只需通过重写pigeon暴露的方法就可以完成双端的通信。而dart侧也只需要通过模板暴露的实例对象来调用接口方法。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/flutter/Flutter零基础介绍.html" class="prev">
        Flutter介绍
      </a></span> <span class="next"><a href="/flutter/Flutter FPS 监控.html">
        如何获取Flutter APP的FPS
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.5d71a1c6.js" defer></script><script src="/assets/js/2.c183a324.js" defer></script><script src="/assets/js/4.24aaf822.js" defer></script>
  </body>
</html>
