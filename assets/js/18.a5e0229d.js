(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{403:function(n,e,r){"use strict";r.r(e);var t=r(45),a=Object(t.a)({},(function(){var n=this,e=n.$createElement,r=n._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h2",{attrs:{id:"markdown-手写js问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#markdown-手写js问题"}},[n._v("#")]),n._v(" @(MarkDown)\n###手写JS问题")]),n._v(" "),r("p",[n._v("#####函数节流 throttle\nthrottle 策略的电梯。保证如果电梯第一个人进来后，50毫秒后准时运送一次，不等待。如果没有人，则待机。")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[n._v("let throttle = (fn, delay = 50) => { // 节流 控制执行间隔时间 防止频繁触发 scroll resize mousemove\n let stattime = 0;\n return function (...args) {\n     let curTime = new Date();\n     if (curTime - stattime >= delay) {\n         fn.apply(this, args);\n         stattime = curTime;\n         }\n     }\n }\n")])])]),r("br"),n._v(" "),r("p",[n._v("#####防抖动 debounce\ndebounce 策略的电梯。如果电梯里有人进来，等待50毫秒。如果又人进来，50毫秒等待重新计时，直到50毫秒超时，开始运送。")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[n._v(" let debounce = (fn, time = 50) => { // 防抖动 控制空闲时间 用户输入频繁\n  let timer;\n  return function (...args) {\n      let that = this;\n      clearTimeout(timer);\n      timer = setTimeout(fn.bind(that, ...args), time);\n      }\n  }\n")])])]),r("p",[n._v("#####Function的bind实现")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[n._v("Function.prototype._bind = function (context) {\n\tlet func = this\n\tlet params = [].slice.call(arguments, 1)\n\treturn function () {\n\t\tparams = params.concat([].slice.call(arguments, 0))\n\t\tfunc.apply(context, params)\n\t}\n}\n")])])]),r("br"),n._v("\n#####函数组合串联compose（koa reduce中间件）\n"),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[n._v("// 组合串联\nlet fn1 = (a) => a + 1;\nlet fn2 = (b) => b + 2;\nlet fn3 = (c) => c + 3;\n\nlet funs = [fn1, fn2, fn3];\n\nlet compose = (func) => {\n    return arg => func.reduceRight((composed, fn) => fn(composed), arg);\n}\nconsole.log(compose(funs)(100)); // 相当于fn1(fn2(fn3(100)))\n")])])]),r("br"),n._v(" "),r("p",[n._v("#####数组展平")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[n._v("let arr = [[1, 2], 3, [[[4], 5]]]; // 数组展平\nfunction flatten(arr) {\n    return [].concat(\n        ...arr.map(x => Array.isArray(x) ? flatten(x) : x)\n    )\n}\n")])])]),r("br"),n._v(" "),r("p",[n._v("#####插入排序")]),n._v(" "),r("blockquote",[r("p",[n._v("插入排序 从后往前比较 直到碰到比当前项 还要小的前一项时 将这一项插入到前一项的后面")])]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[n._v("function insertSort(arr) {\n  let len = arr.length;\n  let preIndex, current;\n  for (let i = 1; i < len; i++) {\n    preIndex = i - 1;\n    current = arr[i]; // 当前项\n    while (preIndex >= 0 && arr[preIndex] > current) {\n      arr[preIndex + 1] = arr[preIndex]; // 如果前一项大于当前项 则把前一项往后挪一位\n      preIndex-- // 用当前项继续和前面值进行比较\n    }\n    arr[preIndex + 1] = current; // 如果前一项小于当前项则 循环结束 则将当前项放到 前一项的后面\n  }\n  return arr;\n}\n")])])]),r("br"),n._v("\n#####选择排序\n> 选择排序 每次拿当前项与后面其他项进行比较 得到最小值的索引位置 然后把最小值和当前项交换位置\n"),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[n._v("function selectSort(arr) {\n  let len = arr.length;\n  let temp = null;\n  let minIndex = null;\n  for (let i = 0; i < len - 1; i++) { // 把当前值的索引作为最小值的索引一次去比较\n    minIndex = i; // 假设当前项索引 为最小值索引\n    for (let j = i + 1; j < len; j++) { // 当前项后面向一次比小\n      if (arr[j] < arr[minIndex]) { // 比假设的值还要小 则保留最小值索引\n        minIndex = j; // 找到最小值的索引位置\n      }\n    }\n    // 将当前值和比较出的最小值交换位置\n    if (i !== minIndex) {\n       temp = arr[i]\n       arr[i] = arr[minIndex];\n       arr[minIndex] = temp;\n    }\n  }\n  return arr;\n}\n")])])]),r("br"),n._v(" "),r("p",[n._v("#####冒泡排序")]),n._v(" "),r("blockquote",[r("p",[n._v("冒泡排序 相邻两项进行比较 如果当前值大于后一项 则交换位置")])]),n._v(" "),r("br"),n._v(" "),r("p",[n._v("#####快速排序（递归）")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[n._v("function quickSort(arr) {\nif (arr.length <= 1) return arr;\nlet midIndex = Math.floor(arr.length / 2);\nlet midNum = arr.splice(midIndex, 1)[0];\nlet left = [];\nlet right = [];\nfor(let i = 0; i < arr.length; i++) {\n    let cur = arr[i];\n    if (cur <= midNum) {\n        left.push(cur);\n    } else {\n        right.push(cur);\n    }\n}\nreturn quickSort(left).concat(midNum, quickSort(right));\n}\n\nlet arr = [2, 4, 12, 9, 22, 10, 18, 6];\nquickSort(arr);\n")])])]),r("br"),n._v(" "),r("p",[n._v("#####数组去重的几种方法")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[n._v('// 1  es6\nlet newArr = [...new Set(arr)];\n// 2  \nArray.prototype.unique2 = function() {\nlet newArr = [];\nlet len = this.length;\nfor(let i = 0; i < len; i++) {\n    let cur = this[i];\n    if(newArr.indexOf(cur) === -1) {\n        newArr[newArr.length] = cur;\n    }\n}\nreturn newArr;\n}\nconsole.log(arr.unique1());\n// 3 最快\nArray.prototype.unique4 = function() {\nlet json = {}, newArr = [], len = this.length;\nfor(var i = 0; i < len; i++) {\n    let cur = this[i];\n    if (typeof json[cur] == "undefined") {\n        json[cur] = true;\n        newArr.push(cur)\n    }\n}\nreturn newArr;\n}\nconsole.log(arr.unique4());\n')])])]),r("p",[n._v("#####千叶符")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[n._v(" let str1 = '2123456789';\nlet str2 = '2123456789.12';\n\n// 利用正向预查 匹配 开头一个数字\\d 后面匹配这个数字后面必须是三个数字为一组为结尾或小数为结尾\nfunction thousandth(str) { \n    let reg = /\\d(?=(?:\\d{3})+(?:\\.\\d+|$))/g; \n    return str.replace(reg, (...rest) => rest[0] + ',');\n}\nconsole.log(thousandth(str1)); // 2,123,456,789\nconsole.log(thousandth(str2)); // 2,123,456,789.12\n")])])]),r("p",[n._v("答案:")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[n._v("\tstr.replace(/(\\d)(?=(?:\\d{3})+$)/g, ' $1,')")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);