(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{357:function(e,t,n){e.exports=n.p+"assets/img/pigeon.db8e754a.jpg"},358:function(e,t,n){e.exports=n.p+"assets/img/pigeon1.63f57823.png"},359:function(e,t,n){e.exports=n.p+"assets/img/pigeon2.55eb2e55.png"},360:function(e,t,n){e.exports=n.p+"assets/img/pigeon4.8e769819.png"},361:function(e,t,n){e.exports=n.p+"assets/img/pigeon3.5374d478.png"},397:function(e,t,n){"use strict";n.r(t);var a=n(45),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[a("img",{attrs:{src:n(357),alt:"enter image description here"}})]),e._v(" "),a("h3",{attrs:{id:"flutter插件开发之pigeon"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flutter插件开发之pigeon"}},[e._v("#")]),e._v(" Flutter插件开发之Pigeon")]),e._v(" "),a("blockquote",[a("p",[e._v("导语：跨端开发中，经常会遇到插件，接口管理上的问题。了解完本文，你将会Flutter是如何通过Pigeon去解决plugin中多端开发难以管理的问题。")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/linpenghui958/flutterPigeonDemo",target:"_blank",rel:"noopener noreferrer"}},[e._v("demo源码地址"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("warning：目前Pigeon还是prerelease版本，所以可能会有breaking change。下文以0.1.7版本为例。")]),e._v(" "),a("p",[e._v("[toc]")]),e._v(" "),a("h4",{attrs:{id:"为何需要pigeon"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为何需要pigeon"}},[e._v("#")]),e._v(" 为何需要Pigeon")]),e._v(" "),a("p",[e._v("在hybird开发中，前端需要native能力，需要native双端开发提供接口。这种情况下就如何规范命名，参数等就成了一个问题，如果单独维护一份协议文件，三端依照协议文件进行开发，很容易出现协议更改后，没有及时同步，又或者在实际开发过程没有按照规范，可能导致各种意外情况。\n在Flutter插件包的开发中，因为涉及到native双端代码实现能力，dart侧暴露统一的接口给使用者，也会出现同样的问题，这里Flutter官方推荐使用Pigeon进行插件管理。")]),e._v(" "),a("h4",{attrs:{id:"pigeon的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pigeon的作用"}},[e._v("#")]),e._v(" Pigeon的作用")]),e._v(" "),a("p",[e._v("Flutter官方提供的Pigeon插件，通过dart入口，生成双端通用的模板代码，Native部分只需通过重写模板内的接口，无需关心methodChannel部分的具体实现，入参，出参也均通过生成的模板代码进行约束。\n假设接口新增，或者参数修改，只需要在dart侧更新协议文件，生成双端模板，即可达到同步更新。")]),e._v(" "),a("p",[e._v("以Flutter官方plugin中的video_player为例，接入pigeon后最终效果如下")]),e._v(" "),a("p",[a("img",{attrs:{src:n(358),alt:"demo"}})]),e._v(" "),a("p",[e._v("可以看到接入pigeon后整体代码简洁了不少，而且规范了类型定义。接下来我们看一下如何从零接入Pigeon。")]),e._v(" "),a("h4",{attrs:{id:"接入pigeon"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接入pigeon"}},[e._v("#")]),e._v(" 接入Pigeon")]),e._v(" "),a("p",[e._v("先看一下pub.dev上Pigeon的"),a("a",{attrs:{href:"https://pub.dev/packages/pigeon",target:"_blank",rel:"noopener noreferrer"}},[e._v("介绍"),a("OutboundLink")],1),e._v("，Pigeon只会生成Flutter与native平台通信所需的模板代码，没有其他运行时的要求，所以也不用担心Pigeon版本不同而导致的冲突。（这里的确不同版本使用起来差异较大，笔者这里接入的时候0.1.7与0.1.10，pigeon默认导出和使用都不相同）")]),e._v(" "),a("h5",{attrs:{id:"创建package"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建package"}},[e._v("#")]),e._v(" 创建package")]),e._v(" "),a("p",[e._v("ps：如果接入已有plugin库，可以跳过此部分，直接看接入部分。")]),e._v(" "),a("p",[e._v("执行生成插件包命令：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("flutter create --org com.exmple --template plugin flutterPigeonDemo\n")])])]),a("p",[e._v("要创建插件包，使用"),a("code",[e._v("--template=plugin")]),e._v("参数执行"),a("code",[e._v("flutter create")])]),e._v(" "),a("ul",[a("li",[a("code",[e._v("lib/flutter_pigeon_demo.dart")]),e._v(" "),a("ul",[a("li",[e._v("插件包的dart api")])])]),e._v(" "),a("li",[a("code",[e._v("android/src/main/kotlin/com/example/flutter_pigeon_demo/FlutterPigeonPlugin.kt")]),e._v(" "),a("ul",[a("li",[e._v("插件包Android部分的实现")])])]),e._v(" "),a("li",[a("code",[e._v("ios/Classes/FlutterPigeonDemoPlugin.m")]),e._v(" "),a("ul",[a("li",[e._v("插件包ios部分的实现。")])])]),e._v(" "),a("li",[a("code",[e._v("example/")]),e._v(" "),a("ul",[a("li",[e._v("使用该插件的flutterdemo。")])])])]),e._v(" "),a("p",[e._v("这里常规通过methodChannel实现plugin的部分省略，主要讲解一下如何接入pigeon插件。")]),e._v(" "),a("h5",{attrs:{id:"添加依赖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#添加依赖"}},[e._v("#")]),e._v(" 添加依赖")]),e._v(" "),a("p",[e._v("首先在"),a("code",[e._v("pubspec.yaml")]),e._v("中添加依赖")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("dev_dependencies:\n  flutter_test:\n    sdk: flutter\n  pigeon:\n    version: 0.1.7\n")])])]),a("p",[e._v("然后按照官方的要求添加一个pigeons目录，这里我们放dart侧的入口文件，内容为接口、参数、返回值的定义，后面通过pigeon的命令，生产native端代码。")]),e._v(" "),a("p",[e._v("这里以"),a("code",[e._v("pigeons/pigeonDemoMessage.dart")]),e._v("为例")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("import 'package:pigeon/pigeon.dart';\n\nclass DemoReply {\n  String result;\n}\n\nclass DemoRequest {\n  String methodName;\n}\n\n// 需要实现的api\n@HostApi()\nabstract class PigeonDemoApi {\n  DemoReply getMessage(DemoRequest params);\n}\n\n// 输出配置\nvoid configurePigeon(PigeonOptions opts) {\n  opts.dartOut = './lib/PigeonDemoMessage.dart';\n  opts.objcHeaderOut = 'ios/Classes/PigeonDemoMessage.h';\n  opts.objcSourceOut = 'ios/Classes/PigeonDemoMessage.m';\n  opts.objcOptions.prefix = 'FLT';\n  opts.javaOut =\n  'android/src/main/kotlin/com/example/flutter_pigeon_demo/PigeonDemoMessage.java';\n  opts.javaOptions.package = 'package com.example.flutter_pigeon_demo';\n}\n")])])]),a("p",[a("code",[e._v("pigeonDemoMessage.dart")]),e._v("文件中定义了请求参数类型、返回值类型、通信的接口以及pigeon输出的配置。")]),e._v(" "),a("p",[e._v("这里"),a("code",[e._v("@HostApi()")]),e._v("标注了通信对象和接口的定义，后续需要在native侧注册该对象，在Dart侧通过该对象的实例来调用接口。")]),e._v(" "),a("p",[a("code",[e._v("configurePigeon")]),e._v("为执行pigeon生产双端模板代码的输出配置。")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("dartOut")]),e._v("为dart侧输出位置")]),e._v(" "),a("li",[a("code",[e._v("objcHeaderOut、objcSourceOut")]),e._v("为iOS侧输出位置")]),e._v(" "),a("li",[a("code",[e._v("prefix")]),e._v("为插件默认的前缀")]),e._v(" "),a("li",[a("code",[e._v("javaOut、javaOptions.package")]),e._v("为Android侧输出位置和包名")])]),e._v(" "),a("p",[e._v("之后我们只需要执行如下命令，就可以生成对应的代码到指定目录中。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("flutter pub run pigeon --input pigeons/pigeonDemoMessage.dart\n")])])]),a("ul",[a("li",[a("code",[e._v("--input")]),e._v("为我们的输入文件")])]),e._v(" "),a("p",[e._v("生成模板代码后的项目目录如下")]),e._v(" "),a("p",[a("img",{attrs:{src:n(359),alt:"catalogue"}})]),e._v(" "),a("p",[e._v("我们在Plugin库中只需要管理标红的dart文件，其余标绿的则为通过Pigeon自动生成的模板代码。")]),e._v(" "),a("p",[e._v("我们接下来看一下双端如何使用Pigeon生成的模板文件。")]),e._v(" "),a("h5",{attrs:{id:"android端接入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#android端接入"}},[e._v("#")]),e._v(" Android端接入")]),e._v(" "),a("p",[e._v("这里Pigeon生产的"),a("code",[e._v("PigeonDemoMessage.java")]),e._v("文件中，可以看到入参和出参的定义"),a("code",[e._v("DemoRequest、DemoReply")]),e._v("，而"),a("code",[e._v("PigeonDemoApi")]),e._v("接口，后面需要在plugin中继承PigeonDemoApi并实现对应的方法，其中setup函数用来注册对应方法所需的methodChannel。")]),e._v(" "),a("blockquote",[a("p",[e._v("ps: 这里生成的PigeonDemoApi部分，setup使用了接口中静态方法的默认实现，这里需要api level 24才能支持，这里需要注意一下。")]),e._v(" "),a("p",[e._v("考虑到兼容性问题，可以将setup的定义转移到plugin中。")])]),e._v(" "),a("p",[e._v("首先需要在plugin文件中引入生成的PigeonDemoMessage中的接口和类。\nFlutterPigeonDemoPlugin先要继承PigeonDemoApi。\n然后在onAttachedToEngine中进行PigeonDemoApi的setup注册。并在plugin中重写PigeonDemoApi中定义的getMessage方法")]),e._v(" "),a("p",[e._v("伪代码部分")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// ... 省略其他引入\nimport com.example.flutter_pigeon_demo.PigeonDemoMessage.*\n\n// 继承PigeonDemoApi\npublic class FlutterPigeonDemoPlugin: FlutterPlugin, MethodCallHandler, PigeonDemoApi {\n\n\t//...\n\toverride fun onAttachedToEngine(@NonNull flutterPluginBinding: FlutterPlugin.FlutterPluginBinding) {\n    \tchannel = MethodChannel(flutterPluginBinding.getFlutterEngine().getDartExecutor(), "flutter_pigeon_demo")\n    \tchannel.setMethodCallHandler(this);\n    \t// pigeon生成的api进行初始化\n    \tPigeonDemoApi.setup(flutterPluginBinding.binaryMessenger, this);\n  \t}\n  \t\n  \t// 重写PigeonDemoApi中的getMessage方法\n\t  override fun getMessage(arg: DemoRequest): DemoReply {\n\t    \tvar reply = DemoReply();\n\t    \treply.result = "pigeon demo result";\n\t    \treturn reply;\n\t}\n}\n\n')])])]),a("h5",{attrs:{id:"ios接入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ios接入"}},[e._v("#")]),e._v(" iOS接入")]),e._v(" "),a("p",[e._v("ios相关目录下的"),a("code",[e._v("PigeonDemoMessage.m")]),e._v("也有"),a("code",[e._v("FLTDemoReply、FLTDemoRequest、FLTPigeonDemoApiSetup")]),e._v("的实现。\n首先需要在plugin中引入头文件"),a("code",[e._v("PigeonDemoMessage.h")]),e._v("，需要在registerWithRegistrar中注册setup函数，并实现getMessage方法。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('#import "FlutterPigeonDemoPlugin.h"\n#import "PigeonDemoMessage.h"\n\n@implementation FlutterPigeonDemoPlugin\n+ (void)registerWithRegistrar:(NSObject<FlutterPluginRegistrar>*)registrar {\n    FlutterPigeonDemoPlugin* instance = [[FlutterPigeonDemoPlugin alloc] init];\n    // 注册api\n    FLTPigeonDemoApiSetup(registrar.messenger, instance);\n}\n\n// 重写getMessage方法\n- (FLTDemoReply*)getMessage:(FLTDemoRequest*)input error:(FlutterError**)error {\n    FLTDemoReply* reply = [[FLTDemoReply alloc] init];\n    reply.result = @"pigeon demo result";\n    return reply;\n}\n\n@end\n\n')])])]),a("h5",{attrs:{id:"dart侧使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dart侧使用"}},[e._v("#")]),e._v(" Dart侧使用")]),e._v(" "),a("p",[e._v("最终在dart侧如何调用呢\n首先看一下lib下Pigeon生成的dart文件"),a("code",[e._v("PigeonDemoMessage.dart")]),e._v(" "),a("code",[e._v("DemoReply、DemoRequest")]),e._v("用来实例化入参和出参\n然后通过"),a("code",[e._v("PigeonDemoApi")]),e._v("的实例去调用方法。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("import 'dart:async';\n\nimport 'package:flutter/services.dart';\nimport 'PigeonDemoMessage.dart';\n\nclass FlutterPigeonDemo {\n  static const MethodChannel _channel =\n      const MethodChannel('flutter_pigeon_demo');\n\n  static Future<String> get platformVersion async {\n    final String version = await _channel.invokeMethod('getPlatformVersion');\n    return version;\n  }\n\n  static Future<DemoReply> testPigeon() async {\n    // 初始化请求参数\n    DemoRequest requestParams = DemoRequest()..methodName = 'requestMessage';\n    // 通过PigeonDemoApi实例去调用方法\n    PigeonDemoApi api = PigeonDemoApi();\n    DemoReply reply = await api.getMessage(requestParams);\n    return reply;\n  }\n\n}\n\n")])])]),a("p",[e._v("至此，Pigeon的接入就已经完成了。")]),e._v(" "),a("h4",{attrs:{id:"接入pigeon后的效果"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接入pigeon后的效果"}},[e._v("#")]),e._v(" 接入Pigeon后的效果")]),e._v(" "),a("p",[e._v("本文demo代码较为简单，接入Pigeon前后的差异并不明显，我们可以看下一Flutter官方plugin中的video_player接入前后的对比。")]),e._v(" "),a("p",[e._v("左侧为接入Pigeon前，处理逻辑都在onMethodCall中，不同的方法通过传入的call.method来区分，代码复杂后很容易变成面条式代码，而且返回的参数也没有约定，有较多不确定因素。")]),e._v(" "),a("p",[e._v("右侧接入Pigeon后，只需要重写对应的方法，逻辑分离，直接通过函数名区分，只需要关心具体的业务逻辑即可。")]),e._v(" "),a("p",[a("img",{attrs:{src:n(360),alt:""}})]),e._v(" "),a("p",[e._v("而在dart的调用侧，接入前都是通过invokeMethod调用，传入的参数map内也是dynamic类型的值。接入后直接调用api的实例对象上的方法，并且通过Pigeon生成的模板代码，直接实例化参数对象。")]),e._v(" "),a("p",[a("img",{attrs:{src:n(361),alt:"pigeon3"}})]),e._v(" "),a("p",[e._v("总结：通过Pigeon来管理Flutter的plugin库，只需要在dart侧维护一份协议即可，即使在多端协同开发的情况下，也能达到约束和规范的作用。")]),e._v(" "),a("p",[e._v("在实现原生插件时我们可以省去很多重复代码，并且不需要关心具体methodchannel的name，也避免了常规情况下，可能出现的面条式代码，只需通过重写pigeon暴露的方法就可以完成双端的通信。而dart侧也只需要通过模板暴露的实例对象来调用接口方法。")])])}),[],!1,null,null,null);t.default=o.exports}}]);